#!/sbin/sh
#Dynamic Installer by BlassGO - based on osm0sis work

unmount() { umount "$1"; umount -l "$1"; }

write_raw_image() { dd if="$1" of="$2"; }

is_substring () { if [[ "$2" == *"$1"* ]]; then true; else false; fi;}

less_than_int() { if [ $1 -lt $2 ]; then true; else false; fi; }

greater_than_int() { if [ $1 -gt $2 ]; then true; else false; fi; }

show_progress() { if ! $BOOTMODE; then echo "progress $1 $2" >> $OUTFD; fi }

apply_patch() { LD_LIBRARY_PATH=/system/lib applypatch "$@"; }

apply_patch_check() { LD_LIBRARY_PATH=/system/lib applypatch -c "$@"; }

apply_patch_space() { LD_LIBRARY_PATH=/system/lib applypatch -s $1; }

abort() { ui_print "$*"; if ! $BOOTMODE; then umount_all; fi; exit 1; }

rename() { mv -f "$1" "$2"; }

delete() { rm -f "$@"; }

delete_recursive() { rm -rf "$@"; }

copy() { cp -prf "$1" "$2"; }

move() { mv -f "$1" "$2"; }

repeat() { printf %${1}s | sed "s/ /$(string escape "$2")/g"; }

defined() { if [ -n "$(checkvar "$1")" ]; then true; else false; fi; }

undefined() { if [ -z "$(checkvar "$1")" ]; then true; else false; fi; }

exist() {
   local func try count restore flag file folder any
   restore=()
   while [[ $# -gt 0 ]]; do
   flag="$1"
   case $flag in
       file)
       file=true
       shift
       ;;
       folder)
       folder=true
       shift
       ;;
       any)
       any=true
       shift
       ;;
       *)   
       restore+=("$1")
       shift
       ;;
   esac
   done
   set -- "${restore[@]}"
   count=0
   func=$#
   if [[ -z "$folder" && -z "$file" && -z "$any" ]]; then any=true; fi
   for try in "$@"; do
      if [[ -n "$file" && -f "$try" ]]; then count=$(( $count + 1 )); fi
      if [[ -n "$any" && -e "$try" ]]; then count=$(( $count + 1 )); fi
      if [[ -n "$folder" && -d "$try" ]]; then count=$(( $count + 1 )); fi
   done
   if [[ "$count" == "$func" ]]; then true; else false; fi
}

is_zip() {
   if xxd -p "$1" | head -n1 | grep -q "504b0304"; then true; else false; fi
}

is_tar() {
   local offset 
   offset=$(echo $(repeat 20 0)7573746172)
   if xxd -p "$1" | grep -q "$offset"; then true; else false; fi
}

is_gzip() {
   if xxd -p "$1" | head -n1 | grep -q "1f8b08"; then true; else false; fi
}

is_bzip() {
   if xxd -p "$1" | head -n1 | grep -q "425a"; then true; else false; fi
}

is_xz() {
   if xxd -p "$1" | head -n1 | grep -q "fd377a585a00"; then true; else false; fi
}

check_content() {
   local array file content func count
   count=0
   array=( "$@" )
   file=${array[${#array[@]} - 1]}
   if [ ! -e "$file" ]; then echo "CANT FIND: $file" && return 1; fi
   if ! is_zip "$file"; then echo "check_content: $file inst a ZIP " && return 1; fi
   unset "array[${#array[@]}-1]"
   func=${#array[@]}
   for content in "${array[@]}"; do
      if unzip -l "$file" | grep -q "$content"; then count=$(( $count + 1 )); fi
   done
   if [[ "$count" == "$func" ]]; then true; else false; fi
}

is_valid() {
   local count func try
   count=0
   func=$#
   for try in "$@"; do
      if [ -e "$try" ] && grep -q '[^[:space:]]' "$try"; then count=$(( $count + 1 )); fi
   done
   if [[ "$count" == "$func" ]]; then true; else false; fi
}

set_metadata() {
  local file i;
  file="$1";
  shift;
  while [ "$2" ]; do
    case $1 in
      uid) chown $2 "$file";;
      gid) chown :$2 "$file";;
      mode) chmod $2 "$file";;
      capabilities) twrp setcap "$file" $2;;
      selabel)
        for i in /system/bin/toybox /system/toolbox /system/bin/toolbox; do
          (LD_LIBRARY_PATH=/system/lib $i chcon -h $2 "$file" || LD_LIBRARY_PATH=/system/lib $i chcon $2 "$file") ;
        done || chcon -h $2 "$file" || chcon $2 "$file";
      ;;
      *) ;;
    esac;
    shift 2;
  done;
}

update_file() {
   local file get newprop prop result propc xml test newprop2 space split
   local restore flag tmp huh save result
   restore=()
   while [[ $# -gt 0 ]]; do
   flag="$1"
   case $flag in
       -delim|-d)
       save=("$1" "$2" "$3")
       shift 3
       ;;
       *)   
       restore+=("$1")
       shift
       ;;
   esac
   done
   set -- "${restore[@]}"
   file="$2"
   if [ ! -e "$file" ]; then echo "CANT FIND: $file" && return 1; fi
   if [ ! -e "$1" ]; then echo "CANT FIND: $1" && return 1; fi
   start_tmp
   tmp="$TMP2/$(basename "$file")"
   cat "$file" > "$tmp"
   while IFS='' read -r prop || [[ -n "$prop" ]]; do
         huh+=("$prop")
   done < "$1"
   update_file_string "${save[@]}" "${huh[@]}" "$tmp"
   result=$?
   inject "$tmp" "$(dirname "$file")"
   end_tmp
   return $result
}

update_file_string() {
   local vars file array newprop prop propc xml result new old
   local restore flag d d2 huh tmp extract newprop2 backdir space space2 newspace
   restore=()
   while [[ $# -gt 0 ]]; do
   flag="$1"
   case $flag in
       -delim|-d)
       d="$2"
       d2="$3"
       shift 3
       ;;
       *)   
       restore+=("$1")
       shift
       ;;
   esac
   done
   set -- "${restore[@]}"
   array=( "$@" )
   file=${array[${#array[@]} - 1]}
   if [ ! -e "$file" ]; then echo "CANT FIND: $file" && return 1; fi
   savestate old "$file"
   tmp="$TMP/$(basename "$file")"
   unset "array[${#array[@]}-1]"
   cat "$file" > "$tmp"
   if [ -n "$d" ]; then
      huh=$(cat "$file")
      backdir="$file"
      extract=$(string complete_extract "$d" "$d2" "$huh")
      file="$tmp"
      echo "$extract" > "$tmp"
   fi
   for prop in "${array[@]}"; do
         if [ -z "$prop" ]; then continue; fi
         newprop=
         propc=
         xml=
         space=
         space2=
         newspace=
         test "${prop#*=}" != "$prop" && propc=1
         test "${prop#*/>}" != "$prop" && xml=1
         test "${prop#*</}" != "$prop" && xml=1
         if [[ -n "$xml" && -n "$propc" ]]; then propc=0; fi
         if [[ "$xml" == "1" ]]; then
             newprop=$(string inside '="' '"' "$prop")
             newprop2=$(string inside ' ' ='"'$newprop'"' "$prop") 
             if [ -n "$newprop" ]; then
               if [[ $(grep -o "$newprop2" "$file" | wc -l) == "1"  ]]; then
                  newprop="$newprop2"
               elif ! is_substring "$newprop2" "$(grep -m1 "$newprop" "$file")"; then
                  newprop=
               fi
             fi
             if [[ -z "$newprop" || "$newprop" == "$prop" ]]; then
                if is_substring '</' "$prop"; then
                   newprop=$(echo "$prop" | sed -e 's/.*<\/\(.*\)>.*/\1/') 
                elif is_substring '/>' "$prop"; then
                   newprop=$(echo "$prop" | sed -e 's/.*<\(.*\)\/>.*/\1/')
                fi
             fi
             if [[ -n "$newprop" && "$newprop" != "$prop" ]]; then
                space=$(grep -m1 "$newprop" "$file" | cut -d'<' -f1)
                space2=$(echo "$prop" | cut -d'<' -f1)
                if [[ "$space" != "$space2" ]]; then
                   newspace="$space"
                fi
             else
                newprop=
                echo2 " WARNING: Abnormal xml $prop"
             fi
         fi   
         if [[ "$propc" == "1" ]]; then  
             newprop=$(echo "$prop" | cut -d '=' -f1 | tr -d " ")
         fi  
         if [ -z "$newprop" ]; then continue; fi
         echo2 "::$newprop"
         prop=$(echo "${newspace}${prop}" | sed -e 's/[]\/$*.^[]/\\&/g')
         result=$(sed "s/.*$(string escape "$newprop").*/${prop}/" "$tmp")
         if [ ! -z "$result" ]; then echo "$result" > "$tmp"; fi
   done
   if [ -n "$d" ]; then
      file="$backdir"
      echo "${huh/$extract/$result}" > "$tmp"
   fi
   if ! is_valid "$tmp"; then echo2 " FATAL ERROR: Invalid $tmp " && return 1; fi
   inject "$tmp" "$(dirname "$file")"
   rm -f "$tmp"
   savestate new "$file"
   if [[ "$old" != "$new" ]]; then true; else false; fi
}

update_file_addon() {
   local restore flag save
   restore=()
   while [[ $# -gt 0 ]]; do
   flag="$1"
   case $flag in
       -delim|-d)
       save=("$1" "$2" "$3")
       shift 3
       ;;
       *)   
       restore+=("$1")
       shift
       ;;
   esac
   done
   set -- "${restore[@]}"
   update_file "${save[@]}" "$addons/$1" "$2"
}

update_file_zip() {
   local restore flag save result
   restore=()
   while [[ $# -gt 0 ]]; do
   flag="$1"
   case $flag in
       -delim|-d)
       save=("$1" "$2" "$3")
       shift 3
       ;;
       *)   
       restore+=("$1")
       shift
       ;;
   esac
   done
   set -- "${restore[@]}"
   package_extract_file "$1" "$TMP/$(basename "$1")"
   update_file "${save[@]}" "$TMP/$(basename "$1")" "$2"
   result=$?
   rm -f "$TMP/$(basename "$1")"
   return $result
}

force_update_file() {
   local file get newprop prop result propc xml test newprop2 space split
   local restore flag tmp huh save
   restore=()
   while [[ $# -gt 0 ]]; do
   flag="$1"
   case $flag in
       -delim|-d)
       save=("$1" "$2" "$3")
       shift 3
       ;;
       *)   
       restore+=("$1")
       shift
       ;;
   esac
   done
   set -- "${restore[@]}"
   file="$2"
   if [ ! -e "$file" ]; then echo "CANT FIND: $file" && return 1; fi
   if [ ! -e "$1" ]; then echo "CANT FIND: $1" && return 1; fi
   start_tmp
   tmp="$TMP2/$(basename "$file")"
   cat "$file" > "$tmp"
   while IFS='' read -r prop || [[ -n "$prop" ]]; do
         huh+=("$prop")
   done < "$1"
   force_update_file_string "${save[@]}" "${huh[@]}" "$tmp"
   result=$?
   inject "$tmp" "$(dirname "$file")"
   end_tmp
   return $result
}

force_update_file_string() {
   local vars file array newprop prop propc xml result old new
   local restore flag d d2 huh tmp extract newprop2 limit backdir space space2 newspace
   restore=()
   while [[ $# -gt 0 ]]; do
   flag="$1"
   case $flag in
       -delim|-d)
       d="$2"
       d2="$3"
       shift 3
       ;;
       *)   
       restore+=("$1")
       shift
       ;;
   esac
   done
   set -- "${restore[@]}"
   array=( "$@" )
   file=${array[${#array[@]} - 1]}
   if [ ! -e "$file" ]; then echo "CANT FIND: $file" && return 1; fi
   savestate old "$file"
   tmp="$TMP/$(basename "$file")"
   unset "array[${#array[@]}-1]"
   cat "$file" > "$tmp"
   if [ -n "$d" ]; then
      huh=$(cat "$file")
      backdir="$file"
      extract=$(string complete_extract "$d" "$d2" "$huh")
      file="$tmp"
      echo "$extract" > "$tmp"
   fi
   for prop in "${array[@]}"; do
         limit=$(($limit + 1))
         newprop=
         propc=
         xml=
         space=
         space2=
         newspace=
         test "${prop#*=}" != "$prop" && propc=1
         test "${prop#*/>}" != "$prop" && xml=1
         test "${prop#*</}" != "$prop" && xml=1
         if [[ -n "$xml" && -n "$propc" ]]; then propc=0; fi
         if [[ "$xml" == "1" ]]; then
             newprop=$(string inside '="' '"' "$prop")
             newprop2=$(string inside ' ' ='"'$newprop'"' "$prop") 
             if [ -n "$newprop" ]; then
               if [[ $(grep -o "$newprop2" "$file" | wc -l) == "1"  ]]; then
                  newprop="$newprop2"
               elif ! is_substring "$newprop2" "$(grep -m1 "$newprop" "$file")"; then
                  newprop=
               fi
             fi
             if [[ -z "$newprop" || "$newprop" == "$prop" ]]; then
                if is_substring '</' "$prop"; then
                   newprop=$(echo "$prop" | sed -e 's/.*<\/\(.*\)>.*/\1/') 
                elif is_substring '/>' "$prop"; then
                   newprop=$(echo "$prop" | sed -e 's/.*<\(.*\)\/>.*/\1/')
                fi
             fi
             if [[ -n "$newprop" && "$newprop" != "$prop" ]]; then
                space=$(grep -m1 "$newprop" "$file" | cut -d'<' -f1)
                space2=$(echo "$prop" | cut -d'<' -f1)
                if [[ "$space" != "$space2" ]]; then
                   newspace="$space"
                fi
             else
                newprop=
                echo2 " WARNING: Abnormal xml $prop"
             fi
         fi   
         if [[ "$propc" == "1" ]]; then  
             newprop=$(echo "$prop" | cut -d '=' -f1 | tr -d " ")
         fi  
         if [ -z "$newprop" ]; then continue; fi
         if [[ "$xml" == "1" && "$limit" == "1" ]]; then
             sed -i '/^$/d' "$tmp"
             last=$(tail -n 1 "$tmp")
             sed -i '$d' "$tmp"
         fi   
         echo2 "::$newprop"
         result=$(awk "!/$(string escape "$newprop")/" "$tmp")
         if [ ! -z "$result" ]; then echo "$result" > "$tmp"; fi
         echo "${newspace}${prop}" >> "$tmp"
   done
   if [[ "$xml" == "1" ]]; then
       echo "$last" >> "$tmp"
   fi
   result=$(cat "$tmp")
   if [ -n "$d" ]; then
      file="$backdir"
      echo "${huh/$extract/$result}" > "$tmp"
   fi
   if ! is_valid "$tmp"; then echo2 " FATAL ERROR: Invalid $tmp " && return 1; fi
   inject "$tmp" "$(dirname "$file")"
   rm -f "$tmp"
   savestate new "$file"
   if [[ "$old" != "$new" ]]; then true; else false; fi
}

force_update_file_addon() {
   local restore flag save
   restore=()
   while [[ $# -gt 0 ]]; do
   flag="$1"
   case $flag in
       -delim|-d)
       save=("$1" "$2" "$3")
       shift 3
       ;;
       *)   
       restore+=("$1")
       shift
       ;;
   esac
   done
   set -- "${restore[@]}"
   force_update_file "${save[@]}" "$addons/$1" "$2"
}

force_update_file_zip() {
   local restore flag save result
   restore=()
   while [[ $# -gt 0 ]]; do
   flag="$1"
   case $flag in
       -delim|-d)
       save=("$1" "$2" "$3")
       shift 3
       ;;
       *)   
       restore+=("$1")
       shift
       ;;
   esac
   done
   set -- "${restore[@]}"
   package_extract_file "$1" "$TMP/$(basename "$1")"
   force_update_file "${save[@]}" "$TMP/$(basename "$1")" "$2"
   result=$?
   rm -f "$TMP/$(basename "$1")"
   return $result
}

flash() {
	unzip -o "$2" "META-INF/com/google/android/update-binary" -p > "$TMP/update-binary-test"
    chmod +x $TMP/update-binary-test
    setdefault "$1" "$($TMP/update-binary-test 3 3 "$2" 2>&1)"
}

flash_addon() {
   flash "$1" "$addons/$2"
}

flash_zip() {
    package_extract_file "$2" "$TMP/$(basename "$2")"
    flash "$1" "$TMP/$(basename "$2")"
    rm -f "$TMP/$(basename "$2")"
}

add_lines() { 
    local old new restore flag al al_add bl bl_add file tmp array lines i
    restore=()
    while [[ $# -gt 0 ]]; do
    flag="$1"
    case $flag in
       -al|-after-line)
       al+=("$2")
       al_add+=("$3")
       shift 3
       ;;
       -bl|-before-line)
       bl+=("$2")
       bl_add+=("$3")
       shift 3
       ;;
       *)   
       restore+=("$1")
       shift
       ;;
    esac
    done
    set -- "${restore[@]}"
    array=( "$@" )
    file=${array[${#array[@]} - 1]}
    unset "array[${#array[@]}-1]"
    start_tmp 
    tmp="$TMP2/$(basename "$file")"
    cat "$file" > "$tmp"
    for lines in "${array[@]}"; do
       cat "$lines" >> "$tmp"
    done
    for i in "${!al[@]}"; do
       add_lines_string -al "${al[i]}" "$(cat "${al_add[i]}")" "$tmp"
    done
    for i in "${!bl[@]}"; do
       add_lines_string -bl "${bl[i]}" "$(cat "${bl_add[i]}")" "$tmp"
    done
    savestate old "$file"
    if ! is_valid "$tmp"; then echo2 " FATAL ERROR: Invalid $tmp" && return 1; fi
    inject "$tmp" "$(dirname "$file")"
    end_tmp
    savestate new "$file"
    if [[ "$old" != "$new" ]]; then true; else false; fi
}

add_lines_string() {
    local vars file array lines restore flag get try
    local al al_add bl bl_add i old new
    restore=()
    while [[ $# -gt 0 ]]; do
    flag="$1"
    case $flag in
       -al|-after-line)
       al+=("$2")
       al_add+=("$3")
       shift 3
       ;;
       -bl|-before-line)
       bl+=("$2")
       bl_add+=("$3")
       shift 3
       ;;
       *)   
       restore+=("$1")
       shift
       ;;
    esac
    done
    set -- "${restore[@]}"
    array=( "$@" )
    file=${array[${#array[@]} - 1]}
    savestate old "$file"
    unset "array[${#array[@]}-1]"
	cat "$file" > "$TMP/$(basename "$file")"
	for lines in "${array[@]}"; do
	   echo "$lines" >> "$TMP/$(basename "$file")"
	done
    if [ -n "$al" ]; then
       for i in "${!al[@]}"; do
          echo "${al_add[i]}" > "$TMP/al.tmp"
          get=$(sed '$!s/$/\\/' $TMP/al.tmp)
          rm -f $TMP/al.tmp
          try=$(cat "$TMP/$(basename "$file")" | sed -e "/${al[i]}/a $get")
          echo "$try" > "$TMP/$(basename "$file")"
       done
    fi
    if [ -n "$bl" ]; then
       for i in "${!bl[@]}"; do
          echo "${bl_add[i]}" > "$TMP/bl.tmp"
          get=$(sed '$!s/$/\\/' $TMP/bl.tmp)
          rm -f $TMP/bl.tmp
          try=$(cat "$TMP/$(basename "$file")" | sed -e "/${bl[i]}/i $get")
          echo "$try" > "$TMP/$(basename "$file")"
       done
    fi
    if ! is_valid "$TMP/$(basename "$file")"; then echo2 " FATAL ERROR: Invalid $TMP/$(basename "$file") " && return 1; fi
    inject "$TMP/$(basename "$file")" "$(dirname "$file")"
    rm -f "$TMP/$(basename "$file")"
    savestate new "$file"
    if [[ "$old" != "$new" ]]; then true; else false; fi
}

add_lines_addon() {
    add_lines "$addons/$1" "$2"
}

add_lines_zip() {
    local result
    package_extract_file "$1" "$TMP/$(basename "$1")"
    add_lines "$TMP/$(basename "$1")" "$2"
    result=$?
    rm -f "$TMP/$(basename "$1")"
    return $result
}

import_config() {
    local ugu propc
    while IFS='' read -r ugu || [[ -n "$ugu" ]]; do
          propc=
          test "${ugu#*=}" != "$ugu" && propc=1
          if [[ "$propc" == "1" ]]; then 
              setdefault "$(split_extract = 1 "$ugu")" "$(split_extract = 2 "$ugu")"
          fi   
    done < "$1"
}

import_config_addon() {
    import_config "$addons/$1"
}

import_config_zip() {
    package_extract_file "$1" "$TMP/$(basename "$1")"
    import_config "$TMP/$(basename "$1")"
    rm -f "$TMP/$(basename "$1")"
}

getdefault() {
  grep -m1 "^setdefault $2" "$1" | tr -d '"' | sed s/"setdefault $2 "//
}

savestate() {
    setdefault "$1" "$(md5sum -b "$2")"
}

startlog() {
    setdefault "logpath" "$1"
    echo > "$1"
}

savelog() {
    local writelog
    if [ -n "$logpath" ]; then
      setdefault writelog "$1"
      echo "${writelog}${n}" >> "$logpath"
    fi
}

symlink() {
  local file="$1";
  while [ "$2" ]; do
    ln -sf "$file" "$2";
    shift;
  done;
}

ch_con_recursive() {
  local dcon fcon i;
  dcon=$1; fcon=$2;
  shift 2;
  while [ "$1" ]; do
    for i in /system/bin/toybox /system/toolbox /system/bin/toolbox; do
      ( find "$1" -type d -exec LD_LIBRARY_PATH=/system/lib $i chcon -h u:object_r:$dcon:s0 {} + || find "$1" -type d -exec LD_LIBRARY_PATH=/system/lib $i chcon u:object_r:$dcon:s0 {} +;
       find "$1" -type f -exec LD_LIBRARY_PATH=/system/lib $i chcon -h u:object_r:$fcon:s0 {} + || find "$1" -type f -exec LD_LIBRARY_PATH=/system/lib $i chcon u:object_r:$fcon:s0 {} +) ;
    done || ( find "$1" -type d -exec chcon -h u:object_r:$dcon:s0 '{}' + || find "$1" -type d -exec chcon u:object_r:$dcon:s0 '{}' + ) || ( find "$1" -type f -exec chcon -h u:object_r:$fcon:s0 '{}' + || find "$1" -type f -exec chcon u:object_r:$fcon:s0 '{}' + );
    shift;
  done;
}

restore_con() {
  local i;
  for i in /system/bin/toybox /system/toolbox /system/bin/toolbox; do
    (LD_LIBRARY_PATH=/system/lib $i restorecon -R "$@") ;
  done || restorecon -R "$@";
}

set_perm_recursive() {
  local uid gid dmod fmod;
  uid=$1; gid=$2; dmod=$3; fmod=$4;
  shift 4;
  while [ "$1" ]; do
    chown -R $uid:$gid "$1" || chown -R $uid.$gid "$1";
    find "$1" -type d -exec chmod $dmod {} +;
    find "$1" -type f -exec chmod $fmod {} +;
    shift;
  done;
}

set_perm_recursive2() {
  #Ensure this perm format
  local uid gid dmod fmod;
  uid=$1; gid=$2; dmod=$3; fmod=$4;
  shift 4;
  while [ "$1" ]; do
    chown -R $uid:$gid "$1" || chown -R $uid.$gid "$1";
    find "$1" -type d -exec chmod $dmod {} +;
    find "$1" -type f -exec chmod $fmod {} +;
    shift;
  done;
}

backup_files() {
  while [ "$1" ]; do
    test ! -e "$1.bak" && cp -pf "$1" "$1.bak";
    shift;
  done;
}

restore_files() {
  while [ "$1" ]; do
    mv -f "${1}.bak" "$1";
    shift;
  done;
}

sha3_check() {
  local sum=$(sha3sum $1 | cut -c-40);
  if [ ! "$2" -o $(is_substring $sum "$*") == 1 ]; then
    echo $sum;
  fi;
}

assert() {
  while [ "$1" ]; do
    $1;
    test $? != 0 && abort 'assert failed('"$1"')';
    shift;
  done;
}

split_string() {
    local split delim
    local IFS=$'\n'
    split="$2"
    split=${split//"$1"/$'\n'}
    for delim in $split; do
        echo "$delim"
    done
}

split_cut() {
    local split count delim
    local IFS=$'\n'
    split="$3"
    split=${split//"$1"/$'\n'}
    count=0
    for delim in $split; do
        count=$(($count + 1))
        echo "$delim"
        if [[ "$count" == "$2" ]]; then return; fi;
    done
}

split_extract() {
    local split count delim
    local IFS=$'\n'
    split="$3"
    split=${split//"$1"/$'\n'}
    count=0
    for delim in $split; do
        count=$(($count + 1))
        if [[ "$count" == "$2" ]]; then echo "$delim" && return; fi;
    done
}

checkvar() {
    local splittt13yu
    for splittt13yu in "$@"; do
      eval splittt13yu="\${${splittt13yu}}" 
	  if [ -n "$splittt13yu" ]; then echo "$splittt13yu"; fi;
	done
}

filtervar() {
    local splittt13yu filter717w8jw array61716opr
    array61716opr=( "$@" )
    filter717w8jw=${array61716opr[${#array61716opr[@]} - 1]}
    unset "array61716opr[${#array61716opr[@]}-1]"
    for splittt13yu in "${array61716opr[@]}"; do
		eval splittt13yu="\${${splittt13yu}}" 
        if [ -n "$splittt13yu" ]; then
           if is_substring "$filter717w8jw" "$splittt13yu"; then echo "$splittt13yu"; fi;
    	fi
    done
}

import_bin() {
    cp -pf "$1" "$l"
    chmod +x "$l/$(basename "$1")" || echo " Cant set: $1" && return 1
}

import_bin_addon() {
   import_bin "$addons/$1"
}

import_bin_zip() {
   local result
   package_extract_file "$1" "$TMP/$(basename "$1")"
   import_bin "$TMP/$(basename "$1")"
   result=$?
   rm -f "$TMP/$(basename "$1")"
   return $result
}

setdefault() {
    read -r -d '' "$1" <<< "$2"
}

is_number() {
   if echo "$1" | grep -E "^[0-9]+$" > /dev/null; then true; else false; fi
}

can_run() {
   local check
   if [ -e "$1" ]; then 
      check=$($1 >/dev/null 2>&1)
      if [[ -x "$1" && "$check" != *"CANNOT LINK"* ]]; then true
      else
         check=$($(which "$1") >/dev/null 2>&1)
         if [[ -x "$(which "$1")" && "$check" != *"CANNOT LINK"* ]]; then true; else false; fi
      fi
   else 
      check=$($(which "$1") >/dev/null 2>&1)
      if [[ -x "$(which "$1")" && "$check" != *"CANNOT LINK"* ]]; then true; else false; fi
   fi
}

make_overlay() {
   #make_overlay 1 com.android FOLDER result.apk
   local package content result tmp current random priority
   priority="$1"
   package="$2"
   content="$3"
   result="$4"
   start_tmp
   tmp="$TMP2/overlay"
   echo ">>Overlay Maker 1.0.0"
   if [[ -z "$package" || -z "$content" || -z "$result" || -z "$priority" || ! -d "$content" ]]; then echo " make_overlay: Invalid line " && return; fi
   echo " L: Detected $package..."
   echo " L: With $content..."
   echo " L: Building $(basename "$result")..."
   random=$(echo "$RANDOM" | tr '[0-9]' '[a-z]')
   dynamic_apktool -d "$l/overlay.apk" -o "$tmp" >/dev/null
   if ! exist "$tmp/AndroidManifest.xml"; then echo " CANT setup: make_overlay " && return 1; fi
   replace "overlay.template" "com.$random.dynamic.installer" "$tmp/AndroidManifest.xml"
   replace 'android:targetPackage="android"' 'android:targetPackage="'$package'"' "$tmp/AndroidManifest.xml"
   replace 'android:priority="1"' 'android:priority="'$priority'"' "$tmp/AndroidManifest.xml"
   delete_recursive "$tmp/res"
   current=${PWD}
   cd "$content"
   cp -prf * "$tmp"
   cd "$current"
   dynamic_apktool -sign -r "$tmp" -o "$result" >/dev/null
   if exist "$result"; then echo " L: Success $(basename "$result")"; else echo " make_overlay: Cant compile $(basename "$result")" && return 1; fi
   end_tmp
}

make_overlay_addon() {
   make_overlay "$1" "$2" "$addons/$3" "$4"
}

make_overlay_zip() {
    local result
    delete_recursive "$TMP/00patch"
    package_extract_dir "$3" "$TMP/00patch"
    make_overlay "$1" "$2" "$TMP/00patch" "$4"
    result=$?
    delete_recursive "$TMP/00patch"
    return $result
}

dynamic_install_apk() {
   local userlist package f try inst_dir package2 
   local temp_dir temp_dest temp_pack check_split check_package restore flag out nr na
   if ! aapt version >/dev/null; then echo " CANT LOAD AAPT: U cant use dynamic_install_apk " && return 1; fi
   restore=()
   while [[ $# -gt 0 ]]; do
   flag="$1"
   case $flag in
       -o|-output)
       out="$2"
       shift 2
       ;;
       -nr|-no-replace)
       nr=true
       shift
       ;;
       -na|-no-add)
       na=true
       shift
       ;;
       *)   
       restore+=("$1")
       shift
       ;;
   esac
   done
   set -- "${restore[@]}"
   delete $TMP/userlist.txt
   delete $TMP/packages.txt
   for userlist in $(find "$2" -type f -name "*.apk"); do
       package=$(aapt dump badging "$userlist" | sed -n "s/.*package: name='\([^']*\).*$/\1/p")
       echo "$userlist" >> $TMP/userlist.txt 
       echo "$(basename "$userlist")=$package" >> $TMP/packages.txt
   done
   for f in $(find "$1" -mindepth 1 -type f -name "*.apk" | cut -d/ -f1-); do
     check_split=
     check_package=
     check_split=$(aapt dump badging "$f" | sed -n "s/.* split='\([^']*\).*$/\1/p")
     if [[ -n "$temp_pack" && -n "$temp_dir" && "$temp_dir" == "$(dirname "$f")" ]]; then
        check_package=$(aapt dump badging "$f" | sed -n "s/.*package: name='\([^']*\).*$/\1/p")
        if [[ -n "$check_split" && "$check_package" == "$temp_pack" ]]; then
           echo2 "add:split: $(basename "$f") in $temp_dest"
           inject "$f" "$temp_dest" && continue
        fi
     fi
     try=
     inst_dir="$(dirname "$f")"
     inst_dir="${inst_dir#$1}"
     package=$(aapt dump badging "$f" | sed -n "s/.*package: name='\([^']*\).*$/\1/p")
     try=$(grep -m1 "$package" "$TMP/packages.txt" | cut -d '=' -f1)
     package2=$(get_file_prop $TMP/packages.txt "$try")
     if [[ "$package" == "$package2" ]]; then try=$(grep -m1 "$try" $TMP/userlist.txt); fi;
     if [[ -n "$try" && -f "$try" && -z "$check_split" ]]; then
        if [ -n "$nr" ]; then continue; fi
        if [ -n "$out" ]; then try="$out$try"; fi
        temp_pack="$package"
        temp_dir=$(dirname "$f")
        temp_dest=$(dirname "$try")
        if ! exist "$temp_dest"; then mkdir -p "$temp_dest"; fi
        echo2 "replace: $package in $try"
        cp -pf "$f" "$try"
        if [ -d "$temp_dir/lib" ]; then cp -pfr "$temp_dir/lib" "$temp_dest"; fi
        set_perm_recursive2 0 0 0755 0644 "$temp_dest"
        ch_con system "$temp_dest"
     elif [ -z "$check_split" ]; then
        if [ -n "$na" ]; then continue; fi
        temp_pack="$package"
        temp_dir=$(dirname "$f")
        temp_dest="$2${inst_dir}"
        if [ -n "$out" ]; then temp_dest="$out$temp_dest"; fi
        echo2 "add: $package in $temp_dest"
        inject "$f" "$temp_dest"
        if [ -d "$temp_dir/lib" ]; then cp -pfr "$temp_dir/lib" "$temp_dest"; fi
        set_perm_recursive2 0 0 0755 0644 "$temp_dest"
     fi
   done  
}

hex_patch() {
    local xxd 
    if xxd --help >/dev/null; then
       xxd=xxd
    elif /system/bin/xxd --help >/dev/null; then 
       xxd="/system/bin/xxd"
    elif /system/bin/toybox xxd --help >/dev/null; then 
       xxd="/system/bin/toybox xxd"
    elif [ ! -e "/data/adb/magisk/magiskboot" ]; then
       echo "CANT LOAD: xxd or magiskboot" && return 1
    fi
    if ! exist "$3"; then echo "CANT FIND: $3" && return 1; fi
    if $($xxd -p "$3" | tr -d \\n | tr -d " " | sed "s/$1/$2/" | $xxd -r -p > "$3.tmp"); then
      if hex_check "$2" "$3.tmp"; then
         mv -f "$3.tmp" "$3"
         true
      elif [ -e "/data/adb/magisk/magiskboot" ]; then
         if $(/data/adb/magisk/magiskboot hexpatch "$3" "$1" "$2"); then
           if hex_check "$2" "$3"; then true; else false; fi
         else
           false
         fi   
      else
         false
      fi
    elif [ -e "/data/adb/magisk/magiskboot" ]; then
        if $(/data/adb/magisk/magiskboot hexpatch "$3" "$1" "$2"); then
           if hex_check "$2" "$3"; then true; else false; fi
        else
           false
        fi 
    else
       false  
    fi
}

hex_search() {
    local xxd restore flag
    local after before
    if xxd --help >/dev/null; then
       xxd=xxd
    elif /system/bin/xxd --help >/dev/null; then 
       xxd="/system/bin/xxd"
    elif /system/bin/toybox xxd --help >/dev/null; then 
       xxd="/system/bin/toybox xxd"
    else
       echo " CANT LOAD XXD bin" && return
    fi
    restore=()
    while [[ $# -gt 0 ]]; do
    flag="$1"
    case $flag in
        -include)
        after=$(echo "$2" | grep -Eio "after:[0-9]+" | cut -f2 -d:)
        before=$(echo "$2" | grep -Eio "before:[0-9]+" | cut -f2 -d:)
        if [[ -z "$after" && -z "$before" ]]; then ui_print "hex_search: invalid line" && return; fi
        shift 2
        ;;
        *)   
        restore+=("$1")
        shift
        ;;
    esac
    done
    set -- "${restore[@]}"
    if ! exist "$2"; then echo "CANT FIND: $2" && return 1; fi
    if [ -z "$after" ]; then after=0; fi
    if [ -z "$before" ]; then before=0; fi
    $xxd -p "$2" | tr -d \\n | tr -d " " | grep -E -o ".{0,${before}}$1.{0,${after}}"
}

hex_check() {
    local xxd
    if xxd --help >/dev/null; then
       xxd=xxd
    elif /system/bin/xxd --help >/dev/null; then 
       xxd="/system/bin/xxd"
    elif /system/bin/toybox xxd --help >/dev/null; then 
       xxd="/system/bin/toybox xxd"
    else
       echo " CANT LOAD XXD bin" && return
    fi
    if ! exist "$2"; then echo "CANT FIND: $2" && return 1; fi
    if $($xxd -p "$2" | tr -d \\n | tr -d " " | grep "$1" >/dev/null); then true; else false; fi
}

getvalue() {
   local try
   try=$1
   shift 1
   TEMP=`getopt --long -o "$try:" "$@"`
   eval set -- "$TEMP"
   while true ; do
       case "$1" in
           -$try )
               echo "$2"
               shift 2
           ;;
           *)
               break
           ;;
       esac 
   done
}

get_equal_value() {
   local equal i
   equal="$1"
   shift 1
   for i in "$@"
   do
   case $i in
       $equal=*)
       echo "${i#*=}"
       shift
       ;;
       *)
       ;;
   esac
   done
}

get_custom_value() {
   local value key
   value="$1"
   shift 1
   while [[ $# -gt 0 ]]
   do
   key="$1"
   case $key in
       $value)
       echo "$2"
       shift 2
       ;;
       *)  
       shift
       ;;
   esac
   done
}

start_tmp(){
   local random
   random=$(echo "$RANDOM" | tr '[0-9]' '[a-z]')
   export TMP2="$TMP/$random"
   kskwiiuwu+=("$TMP2")
   delete_recursive "$TMP2"
   mkdir -p "$TMP2"
}

end_tmp() {
   local i refresh
   delete_recursive "${kskwiiuwu[${#kskwiiuwu[@]} - 1]}"
   unset "kskwiiuwu[${#kskwiiuwu[@]}-1]"
   for i in "${!kskwiiuwu[@]}"; do
      refresh+=("${kskwiiuwu[i]}")
   done
   kskwiiuwu=("${refresh[@]}")
   unset TMP2
}

replace() {
   local restore flag r a file try rpl old new load
   delete "$TMP/replace"
   restore=()
   while [[ $# -gt 0 ]]; do
   flag="$1"
   case $flag in
       -r|-recursive)
       r=true
       shift
       ;;
       -a|-all-line)
       a=true
       shift
       ;;
       *)   
       restore+=("$1")
       shift
       ;;
   esac
   done
   set -- "${restore[@]}"
   file="$3"
   if ! exist "$3"; then echo "CANT FIND: $3" && return 1; fi
   try="$1"
   rpl="$2"
   if [ -n "$r" ]; then
       grep -rn "$file" -e "$try" | while read huh; do
           dir=$(echo "$huh" | cut -f1 -d:)
           savestate old "$dir"
           if [ -n "$a" ]; then
               sed -i "/$(string escape "$try")/s/.*/$(string escape "$rpl")/" "$dir"
           else
               load=$(cat "$dir")
               echo "${load//"$try"/"$rpl"}" > "$dir"
           fi
           savestate new "$dir"
           if [[ "$old" != "$new" ]]; then echo 0 > "$TMP/replace"; else echo 1 > "$TMP/replace"; fi
       done
   else
       savestate old "$file"
       if [ -n "$a" ]; then
           sed -i "/$(string escape "$try")/s/.*/$(string escape "$rpl")/" "$file"
       else
           load=$(cat "$file")
           echo "${load//"$try"/"$rpl"}" > "$file"
       fi
       savestate new "$file"
       if [[ "$old" != "$new" ]]; then echo 0 > "$TMP/replace"; else echo 1 > "$TMP/replace"; fi
   fi
   if [ -f "$TMP/replace" ]; then return $(cat "$TMP/replace"); else return 1; fi
}

getsize() {
   stat -c%s "$1"
}

string() {
   local restore flag string array result
   local replace rpl rpl2 rpll rpll2 rm ca c i try huh upper lower et et2 ex ex2 exn exn2 escape
   restore=()
   while [[ $# -gt 0 ]]; do
   flag="$1"
   case $flag in
       replace)
       rpl+=("$2")
       rpl2+=("$3")
       shift 3
       ;;
       replace_line)
       rpll+=("$2")
       rpll2+=("$3")
       shift 3
       ;;
       remove)
       rm+=("$2")
       shift 2
       ;;
       inside)
       et="$2"
       et2="$3"
       shift 2
       ;;
       extract)
       ex="$2"
       ex2="$3"
       shift 2
       ;;
       complete_extract)
       exn="$2"
       exn2="$3"
       shift 2
       ;;
       upper)
       upper=true
       shift
       ;;
       escape)
       escape=true
       shift
       ;;
       lower)
       lower=true
       shift
       ;;
       count)
       c=true
       shift
       ;;
       *)   
       restore+=("$1")
       shift
       ;;
   esac
   done
   set -- "${restore[@]}"
   array=( "$@" )
   string=${array[${#array[@]} - 1]}
   unset "array[${#array[@]}-1]"
   for i in "${!rpl[@]}"; do
      string="${string//"${rpl[i]}"/"${rpl2[i]}"}"
   done
   for i in "${!rpll[@]}"; do
      try=$(echo "${rpll[i]}" | sed -e 's/[]\/$*.^[]/\\&/g')
      huh=$(echo "${rpll2[i]}" | sed -e 's/[]\/$*.^[]/\\&/g')
      string=$(echo "$string" | sed -e "/$try/s/.*/$huh/")
   done
   for i in "${!rm[@]}"; do
      string="${string//"${rm[i]}"/}"
   done
   if [ -n "$et" ]; then
      try=$(echo "$string" | awk -F "$et|$et2" '{print $2}')
      if [ -n "$try" ]; then string="$try"; fi
   fi
   if [ -n "$ex" ]; then
      try=
      huh=
      try=$(echo "$ex" | sed -e 's/[]\/$*.^[]/\\&/g')
      huh=$(echo "$ex2" | sed -e 's/[]\/$*.^[]/\\&/g')
      try=$(echo "$string" | sed -n "/$try/,/$huh/{p; /$huh/q}" | sed -e '1d;$d')
      if [ -n "$try" ]; then string="$try"; fi
   fi
   if [ -n "$exn" ]; then
      try=
      huh=
      try=$(echo "$exn" | sed -e 's/[]\/$*.^[]/\\&/g')
      huh=$(echo "$exn2" | sed -e 's/[]\/$*.^[]/\\&/g')
      try=$(echo "$string" | sed -n "/$try/,/$huh/{p; /$huh/q}")
      if [ -n "$try" ]; then string="$try"; fi
   fi
   if [[ -n "$upper" && -z "$lower" ]]; then
      string=$(echo "$string" | tr '[:lower:]' '[:upper:]')
   elif [[ -z "$upper" && -n "$lower" ]]; then
      string=$(echo "$string" | tr '[:upper:]' '[:lower:]')
   fi
   if [ -n "$escape" ]; then
      string=$(echo "$string" | sed -e 's/[]\/$*.^[]/\\&/g')
   fi
   if [ -n "$c" ]; then
      echo "${#string}"
   else
      echo "$string"
   fi
}

chooseport() {
  # Keycheck binary by someone755 @Github
  local error=0
  while true; do
    sleep 1
    keycheck_$arch32
    local SEL=$?
    if [ $SEL -eq 42 ]; then
      return 0
    elif [ $SEL -eq 41 ]; then
      return 1
    else
      abort " ERROR: keycheck "
    fi
  done
}

find_block() {
  local BLOCK DEV DEVICE DEVNAME PARTNAME UEVENT
  for BLOCK in "$@"; do
    if [[ "$testmode" != "true" ]]; then 
       DEVICE=`timeout -t 5 find /dev/block \( -type b -o -type c -o -type l \) -iname $BLOCK | head -n 1` 2>/dev/null
    else
       DEVICE=`timeout 5 find /dev/block \( -type b -o -type c -o -type l \) -iname $BLOCK | head -n 1` 2>/dev/null
    fi
    if [ ! -z $DEVICE ]; then
      readlink -f $DEVICE
      return 0
    fi
  done
  # Fallback by parsing sysfs uevents
  for UEVENT in /sys/dev/block/*/uevent; do
    DEVNAME=`grep_prop DEVNAME $UEVENT`
    PARTNAME=`grep_prop PARTNAME $UEVENT`
    for BLOCK in "$@"; do
      if [ "$(toupper $BLOCK)" = "$(toupper $PARTNAME)" ]; then
        echo /dev/block/$DEVNAME
        return 0
      fi
    done
  done
  # Look just in /dev in case we're dealing with MTD/NAND without /dev/block devices/links
  for DEV in "$@"; do
    if [[ "$testmode" != "true" ]]; then
       DEVICE=`timeout -t 5 find /dev \( -type b -o -type c -o -type l \) -maxdepth 1 -iname $DEV | head -n 1` 2>/dev/null
    else
       DEVICE=`timeout 5 find /dev \( -type b -o -type c -o -type l \) -maxdepth 1 -iname $DEV | head -n 1` 2>/dev/null
    fi
    if [ ! -z $DEVICE ]; then
      readlink -f $DEVICE
      return 0
    fi
  done
  return 1
}

toupper() {
  echo "$@" | tr '[:lower:]' '[:upper:]'
}

grep_cmdline() {
  local REGEX="s/^$1=//p"
  cat /proc/cmdline | tr '[:space:]' '\n' | sed -n "$REGEX" 2>/dev/null
}

grep_prop() {
  local REGEX="s/^$1=//p"
  shift
  local FILES=$@
  [ -z "$FILES" ] && FILES='/system/build.prop'
  cat $FILES | dos2unix | sed -n "$REGEX" 2>/dev/null | head -n 1
}

try_mount() {
  local try basetry part result
  for try in "$@"; do
     basetry=$(split_extract / 1 "$try")
     part=$(find_block "$basetry")
     if [[ -n "$part" && -n "$basetry" ]]; then
         setup_mountpoint "$try"
         if ! is_mounted "$try"; then
            if $(mount -w "$try" 2>/dev/null); then
              echo2 " Mounting:1: $part $try"
            elif $(mount -w "$part" "$try" 2>/dev/null); then
              echo2 " Mounting:2: $part $try"
            elif $(mount -t ext4 -w "$part" "$try" 2>/dev/null); then
              echo2 " Mounting:3: $part $try"
            elif $(mount -w,remount -t auto "$try" 2>/dev/null); then
              echo2 " Mounting:4: $part $try"
            elif $(blockdev --setrw "$part" 2>/dev/null); then
              echo2 " Mounting:5: $part $try"
            elif $(mount -r "$try" 2>/dev/null); then
              echo2 " Mounting:ro:1: $part $try"
            elif $(mount -r "$part" "$try" 2>/dev/null); then
              echo2 " Mounting:ro:2: $part $try"
            else
              if ! is_mounted "$try"; then echo2 " CANT MOUNT: $try" && result=1; fi;
            fi
         else
            echo2 " Already mounted: $try"
         fi
     else
        echo2 "Attempted with: $basetry $part"
        if ! is_mounted "$try"; then
           setup_mountpoint "$try"
           if $(mount -w "$try" 2>/dev/null); then
              echo2 " Mounting:noblock:rw: $try"
           elif $(mount -r "$try" 2>/dev/null); then
              echo2 " Mounting:noblock:ro: $try"
           else
              if ! is_mounted "$try"; then echo2 " CANT MOUNT: $try" && result=1; fi;
           fi
        else
           echo2 " Already mounted: $try"
        fi
     fi
     if is_mounted "$try"; then all_umount+=("$try"); fi
  done
  return $result
}

run_wait() {
    local pid count time="$1"
    if ! is_number "$time"; then echo "run_wait: Invalid Line" && return 1; fi
    if exist file "$2"; then chmod +x "$2"; fi
    shift >/dev/null 2>&1 
    $@ & pid=$! count=0
    while kill -0 $pid >/dev/null 2>&1 ; do
        read -t 1 >/dev/null 2>&1 
        count=$(( $count + 1 ))
        if [ $count -ge $time ]; then
            kill $pid >/dev/null 2>&1 && break
        fi
    done
    wait $pid
    return $?
}

run_jar() {
    local dalvikvm file main 
    #Inspired in the osm0sis method
    if dalvikvm -showversion >/dev/null; then
       dalvikvm=dalvikvm
    elif /system/bin/dalvikvm -showversion >/dev/null; then 
       dalvikvm=/system/bin/dalvikvm
    else
       echo "CANT LOAD DALVIKVM " && return 1
    fi
    file="$1"
    unzip -o "$file" "META-INF/MANIFEST.MF" -p > "/data/main.tmp"
    main=$(cat /data/main.tmp | grep -m1 "^Main-Class:" | cut -f2 -d: | tr -d " " | dos2unix)
    rm -f /data/main.tmp
    if [ -z "$main" ]; then
       echo "Cant get main: $file " && return 1
    fi
    shift 1
    $dalvikvm -Djava.io.tmpdir=. -Xnodex2oat -Xnoimage-dex2oat -cp "$file" $main "$@" 2>/dev/null \ || $dalvikvm -Djava.io.tmpdir=. -Xnoimage-dex2oat -cp "$file" $main "$@"
}

run_jar_addon() {
    local file
    file="$1"
    shift 1
    run_jar "$addons/$file" "$@"
}

run_jar_zip() {
    local file result
    file="$1"
    shift 1
    package_extract_file "$file" "$TMP/$(basename "$file")"
    run_jar "$TMP/$(basename "$file")" "$@"
    result=$?
    rm -f "$TMP/$(basename "$file")"
    return $result
}

run_jar_class() {
    local dalvikvm file main class
    #Inspired in the osm0sis method
    if dalvikvm -showversion >/dev/null; then
       dalvikvm=dalvikvm
    elif /system/bin/dalvikvm -showversion >/dev/null; then 
       dalvikvm=/system/bin/dalvikvm
    else
       echo "CANT LOAD DALVIKVM " && return 1
    fi
    file="$1"
    class="$2"
    if [ -z "$class" ]; then
       echo "Class undefined: $file " && return 1
    fi
    shift 2
    $dalvikvm -Djava.io.tmpdir=. -Xnodex2oat -Xnoimage-dex2oat -cp "$file" $class "$@" 2>/dev/null \ || $dalvikvm -Djava.io.tmpdir=. -Xnoimage-dex2oat -cp "$file" $class "$@"
}

run_jar_class_addon() {
    local file
    file="$1"
    shift 1
    run_jar_class "$addons/$file" "$@"
}

run_jar_class_zip() {
    local file result
    file="$1"
    shift 1
    package_extract_file "$file" "$TMP/$(basename "$file")"
    run_jar_class "$TMP/$(basename "$file")" "$@"
    result=$?
    rm -f "$TMP/$(basename "$file")"
    return $result
}

apktool() {
   if [ ! -e /system/framework/framework-res.apk ]; then auto_mount_partitions; fi
   cp -f /system/framework/framework-res.apk $TMP/1.apk
   if [ ! -e "$l/apktool.jar" ]; then ui_print " Cant find apktool.jar " && return 1; fi
   run_jar "$l/apktool.jar" --aapt "$l/aapt" -p $TMP "$@"
}

sign() {
   if [ ! -e $l/zipsigner.jar ]; then ui_print " Cant find zipsigner.jar" && return 1; fi
   run_jar "$l/zipsigner.jar" "$@"
}

dynamic_apktool() {
   #Dynamic Apktool for Dynamic Installer by BlassGO
   local file fullname filename filedir outdir folder outfile sign zipa add alladd move fw check out
   local flag current restore ext ps
   restore=()
   while [[ $# -gt 0 ]]; do
   flag="$1"
   case $flag in
       -d|-decompile)
       file="$2"
       fullname=$(basename "$2")
       filename=${fullname%.*}
       filedir=$(dirname "$2")
       outdir="$filedir/$filename"
       shift 2
       ;;
       -r|-recompile)
       folder="$2"
       outfile=$(cat "$folder/apktool.yml" | grep -m1 "FileName:" | tr -d " " | cut -f2 -d:)
       ext="${outfile##*.}"
       shift 2
       ;;
       -s|-sign)
       sign=true
       shift
       ;;
       -z|-zipalign)
       zipa=true
       shift
       ;;
       -a|-add)
       add=true
       alladd+=$(echo "$2:")
       shift 2
       ;;
       -o|-output)
       move="$2"
       shift 2
       ;;
       -c|-command)
       command="$2"
       shift 2
       ;;
       -ps|-preserve-signature)
       ps=true
       shift
       ;;
       -f|-framework)
       fw="$2"
       shift 2
       ;;
       *)   
       restore+=("$1")
       shift
       ;;
   esac
   done
   set -- "${restore[@]}"
   if [ ! -e /system/build.prop ]; then auto_mount_partitions; fi
   if [ ! -e $l/apktool.jar ]; then ui_print " Cant find apktool.jar " && return 1; fi
   if [ ! -e $l/zipsigner.jar ]; then ui_print " Cant find zipsigner.jar" && return 1; fi
   echo ">>Dynamic Apktool 1.1.0"
   if [[ -n "$file" && -z "$folder" && -z "$zipa" && -z "$sign" ]]; then
      if [ -n "$fw" ]; then cp -f "$fw" $TMP/1.apk; else cp -f /system/framework/framework-res.apk $TMP/1.apk; fi
      if [ -n "$move" ]; then
         rm -rf "$move" 2>/dev/null
         echo " L: Decompiling $fullname... "
         echo " L: Please wait..."
         run_jar $l/apktool.jar --aapt $l/aapt -p $TMP $command d "$file" -o "$move" >/dev/null || echo " ERROR: Cant decompile $fullname" && return 1
         echo " L: Checking results..."
         if [ ! -d "$move" ]; then echo "ERROR: Decompiling $fullname" && return 1; fi
         if [ -n "$add" ]; then
            local IFS=$'\n'
            for add in $(split_string : "$alladd"); do
              echo " L: Adding $(basename "$add")"
              cp -rf "$add" "$move"
            done
         fi
         echo " L: Succes "
      else
         rm -rf "$outdir" 2>/dev/null
         echo " L: Decompiling $fullname..."
         echo " L: Please wait..."
         run_jar $l/apktool.jar --aapt $l/aapt -p $TMP $command d "$file" -o "$outdir" >/dev/null || echo " ERROR: Cant decompile $fullname" && return 1
         echo " L: Checking results..."
         if [ ! -d "$outdir" ]; then ui_print "ERROR: Decompiling $fullname" && return 1; fi
         if [ -n "$add" ]; then
            local IFS=$'\n'
            for add in $(split_string : "$alladd"); do
              echo " L: Adding $(basename "$add")"
              cp -rf "$add" "$outdir"
            done
         fi
      fi
   elif [[ -z "$file" && -n "$folder" ]]; then
         if [ -n "$fw" ]; then cp -f "$fw" $TMP/1.apk; else cp -f /system/framework/framework-res.apk $TMP/1.apk; fi
         rm -f "$folder/try.apk" 2>/dev/null
         rm -rf "$folder/dist" 2>/dev/null
         echo " L: Recompiling $(basename "$folder"). . . " 
         if [ -z "$ps" ]; then
            echo " L: Using all changes..."
            echo " L: Please wait..."
            run_jar $l/apktool.jar --aapt $l/aapt -p $TMP -f $command b "$folder" -o "$folder/try.apk" >/dev/null
         else
            echo " L: Saving signature..."
            echo " L: Please wait..."
            run_jar $l/apktool.jar --aapt $l/aapt -p $TMP -f $command --copy-original b "$folder" -o "$folder/try.apk" >/dev/null
         fi
         if [ ! -e "$folder/try.apk" ]; then echo "ERROR: Compiling $outfile" && return 1; fi
         if [ -n "$add" ]; then
            local IFS=$'\n'
            current=${PWD}
            for add in $(split_string : "$alladd"); do
                echo " L: Adding $(basename "$add")"
                cd "$(dirname "$add")"
                zip -ur "$folder/try.apk" "$(basename "$add")" >/dev/null
            done
            cd "$current"
         fi
         if [ -n "$sign" ]; then
            echo " L: Signing $outfile"
            run_jar "$l/zipsigner.jar" "$folder/try.apk" "$folder/try.zp" >/dev/null
            if [ ! -e "$folder/try.zp" ]; then echo "ERROR: sign $outfile" && return 1; fi
            mv -f "$folder/try.zp" "$folder/try.apk"
         fi
         if [[ -n "$zipa" || "$ext" == "apk" && -n "$ps" ]]; then
            echo " L: Zipaligning $(basename "$outfile")"
            zipalign -f -v 4 "$folder/try.apk" "$folder/try.zp" >/dev/null
            if [ ! -e "$folder/try.zp" ]; then echo "ERROR: zipalign $outfile" && return 1; fi
            mv -f "$folder/try.zp" "$folder/try.apk"
         fi
         if [[ -n "$move" && ! -d "$(dirname "$move")" ]]; then mkdir -p "$(dirname "$move")"; fi
         if [ -n "$move" ]; then mv -f "$folder/try.apk" "$move" && echo " L: Success $(basename "$move")"; else mkdir -p "$folder/dist" && mv -f "$folder/try.apk" "$folder/dist/$outfile" && echo " L: Succes $outfile"; fi
   else
      echo "dynamic_apktool: Invalid line" && return 1
   fi
}

find_apk() {
   local userlist package try restore flag re result
   if ! aapt version >/dev/null; then echo " CANT LOAD AAPT: U cant use find_apk " && return 1; fi
   result=1
   restore=()
   while [[ $# -gt 0 ]]; do
   flag="$1"
   case $flag in
       -r|-recursive)
       re=true
       shift
       ;;
       *)   
       restore+=("$1")
       shift
       ;;
   esac
   done
   set -- "${restore[@]}"
   delete $TMP/userlist.txt
   delete $TMP/packages.txt
   for userlist in $(find "$2" -type f -name "*.apk"); do
       package=$(aapt dump badging "$userlist" | sed -n "s/.*package: name='\([^']*\).*$/\1/p" 2>/dev/null)
       echo "$userlist" >> $TMP/userlist.txt 
       echo "$(basename "$userlist")=$package" >> $TMP/packages.txt
   done
   for try in $(grep "$1" "$TMP/packages.txt" | cut -d '=' -f1); do
     package=
     package=$(get_file_prop $TMP/packages.txt "$try")
     if [ -z "$re" ]; then
        if [[ "$package" == "$1" ]]; then echo "$(grep -m1 "$try" $TMP/userlist.txt)" && return; fi;
     else
        result=0
        echo "$(grep -m1 "$try" $TMP/userlist.txt)"
     fi
   done
   return $result
}

apk_package() {
   local package
   if ! aapt version >/dev/null; then echo " CANT LOAD AAPT: U cant use apk_package " && return 1; fi
   package=$(aapt dump badging "$1" | sed -n "s/.*package: name='\([^']*\).*$/\1/p" 2>/dev/null)
   if [ -n "$package" ]; then echo "$package"; else return 1; fi
}

apk_pkg() {
   apk_package "$@"
}

patch_apk() {
    cp -pf "$2" $TMP
    cd "$1" && zip -r "$TMP/$(basename "$2")" *
    if [[ "$3" == "zipalign" ]]; then
       zipalign -f -v 4 "$TMP/$(basename "$2")" "$TMP/$(basename "$2").zp"
       if [ -e "$TMP/$(basename "$2").zp" ]; then
          mv -f "$TMP/$(basename "$2").zp" "$TMP/$(basename "$2")"
       else
          echo "ERROR: zipalign $2" && return 1
       fi
    fi
    if [[ "$3" == "sign" ]]; then
       if [ ! -e $l/zipsigner.jar ]; then ui_print " Cant find zipsigner.jar " && return 1; fi
       run_jar "$l/zipsigner.jar" "$TMP/$(basename "$2")" "$TMP/$(basename "$2").zp"
       if [ -e "$TMP/$(basename "$2").zp" ]; then
          mv -f "$TMP/$(basename "$2").zp" "$TMP/$(basename "$2")"
       else
          echo "ERROR: sign $2" && return 1
       fi
    fi
    inject "$TMP/$(basename "$2")" "$(dirname "$2")"
}

patch_apk_addon() {
   patch_apk "$addons/$1" "$2" "$3"
}

patch_apk_zip() {
    local result
    rm -rf "$TMP/patch_apk"
    package_extract_dir "$1" "$TMP/patch_apk"
    patch_apk "$TMP/patch_apk" "$2" "$3"
    result=$?
    rm -rf "$TMP/patch_apk"
    return $result
}

progress() {
    # command & progress
    local pid=$! huh delay=0.1 limit=10 count=0 anim='|/-\' finish=10 mark="=========================================="
    while kill -0 "$pid" 2> /dev/null; do
        sleep $delay
        local temp=${anim#?}
        local pd=$(( $count * 73 / $finish ))
        if [[ "$count" == "2" ]]; then sleep 0.3 && count=$(( $count + 1 )); fi
        if [[ "$count" == "3" ]]; then sleep 0.3 && count=$(( $count + 1 )); fi
        if [[ "$count" -le "4" ]]; then count=$(( $count + 1 )); fi
        printf "\r %c %3d.%1d%% %.${pd}s" $anim $(( $count * 100 / $finish )) $(( ($count * 1000 / $finish) % 10 )) $mark
        local anim=$temp${anim%"$temp"}
    done
    while [[ $count -lt $limit ]]; do
        sleep $delay
        local temp=${anim#?}
        local pd=$(( $count * 73 / $finish ))
        count=$(( $count + 1 ))
        printf "\r %c %3d.%1d%% %.${pd}s" $anim $(( $count * 100 / $finish )) $(( ($count * 1000 / $finish) % 10 )) $mark
        local anim=$temp${anim%"$temp"}
    done
    echo
}

progress_print() {
    # command & progress_print " file to print"
    local pid=$! check check2 idk=0 file="$1" delay=0 count=0
    local huh limit uwu
    limit=$(cat "$file" | wc -l)
    huh=$(( $limit / 4 ))
    while read uwu; do
       while kill -0 "$pid" 2> /dev/null; do
           count=$(( $count + 1 ))
           sleep $delay
           if [[ "$uwu" != "$check" ]]; then
              if [[ "$count" -lt "$huh" ]]; then 
                 ui_print "$uwu"
              fi
              if [[ "$count" -lt "$(( $count * 2 ))" ]]; then 
                 ui_print "$uwu"
              fi
           fi
           check="$uwu"
       done
       while [[ "$idk" -lt "$limit" ]]; do
         if [[ "$uwu" != "$check2" && "$uwu" != "$check" ]]; then
            idk=$(( $idk + 1 ))
            sleep $delay
            ui_print "$uwu"
            check2="$uwu"
         else
            break
         fi
       done
    done < "$file"
    echo
}


progress_script() {
   local huh
   #progress_script script/commands
   huh="$@"
   if [ -z "$huh" ]; then return; fi
   $("$@" >/dev/null 2>&1) & progress
}

start_loading() {
   #start_loading -s 10 -f 100 -a '|/-\' -l [..................................]
   #start_loading -s(tart) 10 -f(inish) 100 -d(elay) 0.5 -a(nimation) '|/-\' -l(inear) [..................................]
   local complete=$(getvalue s $@ 2>/dev/null)
   export mark=$(getvalue l $@ 2>/dev/null)
   export loafinish=$(getvalue f $@ 2>/dev/null)
   export delay=$(getvalue d $@ 2>/dev/null)
   export loacount=0
   export anim=$(getvalue a $@ 2>/dev/null)
   for huh in complete loafinish; do
      uwu=$(checkvar $huh)
      if [ -z "$uwu" ]; then
         echo "start loading: Fatal line" && return
      fi
   done
   if [ -z "$delay" ]; then export delay="0.3" ; fi;
   while [[ $loacount -lt $loafinish && $loacount -lt $complete ]]; do
     sleep $delay
     local temp=${anim#?}
     export loacount=$(( $loacount + 1 ))
     export pd=$(( $loacount * 73 / $loafinish ))
     if [[ -n "$mark" && -n "$anim" ]]; then
        printf "\r %c %3d.%1d%% %.${pd}s" $anim $(( $loacount * 100 / $loafinish )) $(( ($loacount * 1000 / $loafinish) % 10 )) $mark
        local anim=$temp${anim%"$temp"}
     elif [[ -z "$mark" && -n "$anim" ]]; then
        printf "\r %c %3d.%1d%%" $anim $(( $loacount * 100 / $loafinish )) $(( ($loacount * 1000 / $loafinish) % 10 ))
        local anim=$temp${anim%"$temp"}
     elif [[ -n "$mark" && -z "$anim" ]]; then
        printf "\r%3d.%1d%% %.${pd}s" $(( $loacount * 100 / $loafinish )) $(( ($loacount * 1000 / $loafinish) % 10 )) $mark
     else
       printf "\r%3d.%1d%%" $(( $loacount * 100 / $loafinish )) $(( ($loacount * 1000 / $loafinish) % 10 ))
     fi
   done
   if [[ "$loacount" -ge "$loafinish" ]]; then echo ; fi;
}

add_loading() {
   local complete=$1
   local add=0
   for huh in complete loafinish; do
      uwu=$(checkvar $huh)
      if [ -z "$uwu" ]; then
         echo "add loading: Fatal line or undefined start_loading" && return
      fi
   done
   while [[ $loacount -lt $loafinish && $add -lt $complete ]]; do
     sleep $delay
     local temp=${anim#?}
     export loacount=$(( $loacount + 1 ))
     add=$(( $add + 1 ))
     export pd=$(( $loacount * 73 / $loafinish ))
     if [[ -n "$mark" && -n "$anim" ]]; then
        printf "\r %c %3d.%1d%% %.${pd}s" $anim $(( $loacount * 100 / $loafinish )) $(( ($loacount * 1000 / $loafinish) % 10 )) $mark
        local anim=$temp${anim%"$temp"}
     elif [[ -z "$mark" && -n "$anim" ]]; then
        printf "\r %c %3d.%1d%%" $anim $(( $loacount * 100 / $loafinish )) $(( ($loacount * 1000 / $loafinish) % 10 ))
        local anim=$temp${anim%"$temp"}
     elif [[ -n "$mark" && -z "$anim" ]]; then
        printf "\r%3d.%1d%% %.${pd}s" $(( $loacount * 100 / $loafinish )) $(( ($loacount * 1000 / $loafinish) % 10 )) $mark
     else
       printf "\r%3d.%1d%%" $(( $loacount * 100 / $loafinish )) $(( ($loacount * 1000 / $loafinish) % 10 ))
     fi
   done
   if [[ "$loacount" -ge "$loafinish" ]]; then echo ; fi;
}

smali_kit() {
   #Smali Tool kit for Dynamic Installer by BlassGO
   local dir num line liner old new count=0 restore load try log
   local file path method replace limit rim newline oldline check stock edit smaliname remake
   local get al al_add bl bl_add staticname dim dim_oldline justprint printpath prev dm
   local restore flag 
   delete "$TMP/smali_kit"
   restore=()
   while [[ $# -gt 0 ]]; do
   flag="$1"
   case $flag in
       -f|-file)
       file="$2"
       shift 2
       ;;
       -d|-dir)
       path="$2"
       shift 2
       ;;
       -m|-method)
       method="$2"
       shift 2
       ;;
       -r|-replace)
       replace="$2"
       shift 2
       ;;
       -rim|-replace-in-method)
       rim=true
       oldline="$2"
       newline="$3"
       shift 3
       ;;
       -dim|-delete-in-method)
       dim=true
       dim_oldline="$2"
       shift 2
       ;;
       -re|-remake)
       remake="$2"
       shift 2
       ;;
       -al|-after-line)
       al="$2"
       al_add="$3"
       shift 3
       ;;
       -bl|-before-line)
       bl="$2"
       bl_add="$3"
       shift 3
       ;;
       -c|-check)
       check=true
       shift
       ;;
       -n|-name)
       smaliname="$2"
       shift 2
       ;;
       -sn|-static-name)
       staticname="$2"
       shift 2
       ;;
       -l|-limit)
       limit="$2"
       shift 2
       ;;
       -pp|-print-path)
       printpath=true
       shift
       ;;
       -dm|-delete-method)
       dm=true
       shift
       ;;
       *)   
       restore+=("$1")
       shift
       ;;
   esac
   done
   set -- "${restore[@]}"
   if [[ -z "$file" && -n "$path" && -n "$method" ]]; then
      grep -rnw "$path" -e "$method" | while read huh; do
         stock=
         edit=
         dir=$(echo "$huh" | cut -f1 -d:)
         num=$(echo "$huh" | cut -f2 -d:)
         liner=$(echo "$huh" | cut -f3 -d:)
         if [[ "$liner" == *".method"* && "$liner" != *".method abstract"* && "$liner" != *".method public abstract"* ]]; then
            if [[ -n "$staticname" && "$(basename "$dir")" != "$staticname" ]]; then continue; fi
            if [[ -n "$smaliname" && "$(basename "$dir")" != *"$smaliname"* ]]; then continue; fi
            if [ -n "$printpath" ]; then if [[ "$dir" != "$prev" ]]; then 
               count=$(( $count + 1 ))
               echo "$dir"
               echo 0 > "$TMP/smali_kit"
               if [[ -n "$limit" && "$limit" == "$count" ]]; then break; fi
               prev="$dir" && justprint=true && continue
            fi; fi
            line=$(echo "$liner" | sed -e 's/[]\/$*.^[]/\\&/g')
            savestate stock "$dir"
            if [[ -z "$replace" && -z "$rim" && -z "$remake" && -z "$al" && -z "$bl" && -z "$dim" && -z "$printpath" && -z "$dm" ]]; then
               justprint=true
               echo "path=$dir"
               sed -n "/$line/,/\.end method/p" "$dir"
            fi
            if [ -n "$replace" ]; then
               load=$(cat "$dir")
               old=$(sed -n "/$line/,/\.end method/p" "$dir")
               echo "${load/"$old"/"$replace"}" > "$dir"
            fi
            if [[ -n "$rim" && -n "$oldline" && -n "$newline" ]]; then
               old=$(sed -n "/$line/,/\.end method/p" "$dir")
               try=${old/"$oldline"/"$newline"}
               load=$(cat "$dir")
               echo "${load/"$old"/"$try"}" > "$dir"
            fi
            if [[ -n "$dim" && -n "$dim_oldline" ]]; then
               old=$(sed -n "/$line/,/\.end method/p" "$dir")
               try=${old//"$dim_oldline"/}
               load=$(cat "$dir")
               echo "${load/"$old"/"$try"}" > "$dir"
            fi
            if [ -n "$remake" ]; then
               old=$(sed -n "/$line/,/\.end method/p" "$dir")
               echo "${liner}" > "$TMP/re.tmp"
               echo "$remake" >> "$TMP/re.tmp"
               echo "${n}.end method" >> "$TMP/re.tmp"
               try=$(cat "$TMP/re.tmp")
               rm -f "$TMP/re.tmp" 2>/dev/null
               load=$(cat "$dir")
               echo "${load/"$old"/"$try"}" > "$dir"
            fi
            if [[ -n "$bl" && -n "$bl_add" ]]; then
               old=$(sed -n "/$line/,/\.end method/p" "$dir") 
               echo "$bl_add" > "$TMP/bl.tmp"
               get=$(sed '$!s/$/\\/' "$TMP/bl.tmp")
               rm -f "$TMP/bl.tmp"
               try=$(echo "$old" | sed "/$bl/i $get")
               load=$(cat "$dir")
               echo "${load/"$old"/"$try"}" > "$dir"
            fi
            if [[ -n "$al" && -n "$al_add" ]]; then
               old=$(sed -n "/$line/,/\.end method/p" "$dir") 
               echo "$al_add" > "$TMP/al.tmp"
               get=$(sed '$!s/$/\\/' "$TMP/al.tmp")
               rm -f "$TMP/al.tmp"
               try=$(echo "$old" | sed -e "/$al/a $get")
               load=$(cat "$dir")
               echo "${load/"$old"/"$try"}" > "$dir"
            fi
            if [ -n "$dm" ]; then
               load=$(cat "$dir")
               old=$(sed -n "/$line/,/\.end method/p" "$dir") 
               echo "${load//"$old"/}" > "$dir"
            fi
            savestate edit "$dir"
            if [ -z "$printpath" ]; then count=$(( $count + 1 )); fi
            if [ -n "$check" ]; then if [[ "$edit" != "$stock" ]]; then ui_print "Edited: "$dir""; else ui_print "Nothing: "$dir""; fi; fi
            if [[ "$edit" != "$stock" ]]; then echo 0 > "$TMP/smali_kit"; else echo 1 > "$TMP/smali_kit"; fi
            if [ -n "$justprint" ]; then echo 0 > "$TMP/smali_kit"; fi
            if [[ -n "$limit" && "$limit" == "$count" ]]; then break; fi
         fi
      done
   elif [[ -n "$file" && -z "$path" && -n "$method" ]]; then
      grep -nw "$file" -e "$method" | while read huh; do
         stock=
         edit=
         num=$(echo "$huh" | cut -f1 -d:)
         liner=$(echo "$huh" | cut -f2 -d:)
         if [[ "$liner" == *".method"* && "$liner" != *".method abstract"* && "$liner" != *".method public abstract"* ]]; then
            if [[ -n "$staticname" && "$(basename "$file")" != "$staticname" ]]; then continue; fi
            if [[ -n "$smaliname" && "$(basename "$file")" != *"$smaliname"* ]]; then continue; fi
            line=$(echo "$liner" | sed -e 's/[]\/$*.^[]/\\&/g')
            savestate stock "$file"
            if [[ -z "$replace" && -z "$rim" && -z "$remake" && -z "$al" && -z "$bl" && -z "$dm" ]]; then
               justprint=true
               echo "path="$dir""
               sed -n "/$line/,/\.end method/p" "$file"
            fi
            if [ -n "$replace" ]; then
               load=$(cat "$file")
               old=$(sed -n "/$line/,/\.end method/p" "$file")
               echo "${load/"$old"/"$replace"}" > "$file"
            fi
            if [[ -n "$rim" && -n "$oldline" && -n "$newline" ]]; then
               old=$(sed -n "/$line/,/\.end method/p" "$file")
               try=${old/"$oldline"/"$newline"}
               load=$(cat "$file")
               echo "${load/"$old"/"$try"}" > "$file"
            fi
            if [[ -n "$dim" && -n "$dim_oldline" ]]; then
               old=$(sed -n "/$line/,/\.end method/p" "$file")
               try=${old//"$dim_oldline"/}
               load=$(cat "$file")
               echo "${load/"$old"/"$try"}" > "$file"
            fi
            if [ -n "$remake" ]; then
               old=$(sed -n "/$line/,/\.end method/p" "$file")
               echo "${liner}" > "$TMP/re.tmp"
               echo "$remake" >> "$TMP/re.tmp"
               echo "${n}.end method" >> "$TMP/re.tmp"
               try=$(cat "$TMP/re.tmp")
               rm -f "$TMP/re.tmp" 2>/dev/null
               load=$(cat "$file")
               echo "${load/"$old"/"$try"}" > "$file"
            fi
            if [[ -n "$bl" && -n "$bl_add" ]]; then
               old=$(sed -n "/$line/,/\.end method/p" "$file") 
               echo "$bl_add" > "$TMP/bl.tmp"
               get=$(sed '$!s/$/\\/' "$TMP/bl.tmp")
               rm -f "$TMP/bl.tmp"
               try=$(echo "$old" | sed "/$bl/i $get")
               load=$(cat "$file")
               echo "${load/"$old"/"$try"}" > "$file"
            fi
            if [[ -n "$al" && -n "$al_add" ]]; then
               old=$(sed -n "/$line/,/\.end method/p" "$file") 
               echo "$al_add" > "$TMP/al.tmp"
               get=$(sed '$!s/$/\\/' "$TMP/al.tmp")
               rm -f "$TMP/al.tmp"
               try=$(echo "$old" | sed -e "/$al/a $get")
               load=$(cat "$file")
               echo "${load/"$old"/"$try"}" > "$file"
            fi
            if [ -n "$dm" ]; then
               load=$(cat "$file")
               old=$(sed -n "/$line/,/\.end method/p" "$file") 
               echo "${load//"$old"/}" > "$file"
            fi
            savestate edit "$file"
            count=$(( $count + 1 ))
            if [ -n "$check" ]; then if [[ "$edit" != "$stock" ]]; then ui_print "Edited: "$file""; else ui_print "Nothing: "$file""; fi; fi
            if [[ "$edit" != "$stock" ]]; then echo 0 > "$TMP/smali_kit"; else echo 1 > "$TMP/smali_kit"; fi
            if [ -n "$justprint" ]; then echo 0 > "$TMP/smali_kit"; fi
            if [[ -n "$limit" && "$limit" == "$count" ]]; then break; fi
         fi
      done
   else
      echo " smali_kit: Invalid line " && return 1
   fi
   if [ -f "$TMP/smali_kit" ]; then return $(cat "$TMP/smali_kit"); else return 1; fi
}

apex_pkg() {
    rm -f "/data/pkg.info"
	unzip -o "$1" "apex_build_info.pb" -p > "/data/pkg.info"
    awk '/package=/ {print $1}' "/data/pkg.info" | tr -d '"' | tr -d '>' | sed s/"package="//
    rm -f "/data/pkg.info"
}

getarch() {
  local try
  if [ ! -f /system/build.prop ]; then
     API=`getprop ro.build.version.sdk`
     ABI=`getprop ro.product.cpu.abi | cut -c-3`
     ABI2=`getprop ro.product.cpu.abi2 | cut -c-3`
     ABILONG=`getprop ro.product.cpu.abi`
  else
     API=`get_file_prop /system/build.prop ro.build.version.sdk`
     ABI=`get_file_prop /system/build.prop ro.product.cpu.abi | cut -c-3`
     ABI2=`get_file_prop /system/build.prop ro.product.cpu.abi2 | cut -c-3`
     ABILONG=`get_file_prop /system/build.prop ro.product.cpu.abi`
  fi

  arch=arm
  arch32=arm
  is64bit=false
  if [ -e "/proc/cpuinfo" ]; then 
     try=$(cat /proc/cpuinfo | grep -m1 "architecture" | cut -d':' -f2 | tr -d " ")
     if is_number "$try"; then
        if [[ "$try" == "8" ]]; then ABILONG="arm64-v8a"
        elif [[ "$try" == "7" ]]; then ABILONG="arm"
        fi
     fi
  fi
  if [ "$ABI" = "x86" ]; then arch=x86; arch32=x86; fi;
  if [ "$ABI2" = "x86" ]; then arch=x86; arch32=x86; fi;
  if [ "$ABILONG" = "arm64-v8a" ]; then arch=arm64; arch32=arm; is64bit=true; fi;
  if [ "$ABILONG" = "x86_64" ]; then arch=x64; arch32=x86; is64bit=true; fi;
}

getbins() {
  #Deprecated
  local support pos
  unset bins
  for support in $(echo "$PATH" | tr ':' ' '); do
      pos=$(basename "$(ls -a "$support" | tr '\n' ' ')")
      if [ -d "$support" ]; then export bins+=$(echo "$(basename "$support"):: $pos" ); fi
  done
}

run() {
    local current file var
    current="$(dirname "$2")"
    file="$(basename "$2")"
    var="$1"
    shift 2
    chmod +x "$current/$file"
    setdefault "$var" "$($current/$file "$@" 2>&1)"
}

run_addon() {
    local file var
    file="$2"
    var="$1"
    shift 2
    run "$var" "$addons/$file" "$@"
}

run_zip() {
    local file var
    file="$2"
    var="$1"
    shift 2
    package_extract_file "$file" "$TMP/$(basename "$file")"
    run "$var" "$TMP/$(basename "$file")" "$@"
    rm -f "$TMP/$(basename "$file")"
}

package_extract_file() { 
   local file ext
   [ -d $(dirname "$2") ] || mkdir -p $(dirname "$2") && set_perm2 0 0 755 "$(dirname "$2")"
   file=$(basename "$2")
   ext="${file##*.}"
   unzip -o "$installzip" "$1" -p > "$2"
   if [[ "$ext" == "sh" ]]; then chmod +x "$2"; else set_perm2 0 0 644 "$2"; fi;
}

package_extract_dir() {
  local outfile file ext
  for a in $(unzip -l "$installzip" | tail -n+4 | grep -v '/$' | grep -o " $1.*$" | cut -c2-); do                         
    outfile="$(echo "$a" | sed "s|${1}|${2}|")";
    file=$(basename "$outfile")
    ext="${file##*.}"
    [ -d $(dirname "$outfile") ] || mkdir -p $(dirname "$outfile") && set_perm2 0 0 755 "$(dirname "$outfile")"
    unzip -o "$installzip" "$a" -p > "$outfile"
    if [[ "$ext" == "sh" ]]; then chmod +x "$outfile"; else set_perm2 0 0 644 "$outfile"; fi;
  done;
}

echo2() {
   >&2 echo "$@"
}

getblocks() {
   #Deprecated
   local block block2 mapper bd
   unset all_partitions
   dynamic_partitions=`getprop ro.boot.dynamic_partitions`
   slot=$(getprop ro.boot.slot_suffix )
   for block in /dev/block/platform/*/by-name/*; do
       if [ -e "$block" ]; then
          eval $(basename $block)="$block"
          echo2 "$(basename $block)="$block""
          export all_partitions+="$(basename $block) "
       else
          for block2 in /dev/block/by-name/*; do
             if [ -e "$block2" ]; then
                eval $(basename $block2)="$block2"
                echo2 "$(basename $block2)="$block2""
                export all_partitions+="$(basename $block2) "
             fi
          done 
       fi
   done
   if [ "$dynamic_partitions" = "true" ]; then
       for mapper in system vendor odm product; do
           if [ -e "/dev/block/mapper/$mapper" ]; then
              eval $mapper="/dev/block/mapper/$mapper$slot"
              echo2 "$mapper="/dev/block/mapper/$mapper$slot""
              export all_partitions+="$(echo "$mapper$slot") "
           fi
       done
   else
       for bd in system cache; do
           if [ -e "/dev/block/bootdevice/$bd" ]; then
              eval $bd="/dev/block/bootdevice/$bd$slot"
              echo2 "$bd="/dev/block/bootdevice/$bd$slot""
              export all_partitions+="$(echo "$bd$slot") "
           fi
       done
   fi
}

fprint() {
  local line
  while IFS='' read -r line || [[ -n "$line" ]]; do
    ui_print "$line";
  done < "$1";
}

fprint_zip() {
  package_extract_file "$1" "$TMP/$1"
  fprint "$TMP/$1"
  rm -f "$TMP/$1"
}

fprint_addon() {
  fprint "$addons/$1"
}

update() {
    local block dd
    if [ "$(echo $2 | grep ' ')" ]; then
        block=$(echo $2 | cut -d\  -f1);
        dd=$(echo $block | cut -d\  -f2-);
    elif [ ! "$dd" ]; then
        dd="bs=1048576";
    fi;
	if `simg2img "$1" "$2"`; then
        echo2 " "
		echo2 "-- Updated: $(basename $1)"
		echo2 " "
	elif `dd if="$1" of="$2" $dd`; then
        echo2 " "
		echo2 "-- Updated: $(basename $1)"
		echo2 " "
    elif `cat "$1" > "$2"`; then
        echo2 " "
		echo2 "-- Updated: $(basename $1)"
		echo2 " "
    else
        echo2 " "
        echo2 " -- Cant update: $(basename $1)"
        echo2 " "
        exit 1
	fi
}

update_addon() {
    update "$addons/$1" "$2"
}

update_zip() {
    package_extract_file "$1" "$TMP/$(basename "$1")"
    update "$TMP/$(basename "$1")" "$2"
    rm -f "$TMP/$(basename "$1")"
}

get_file_prop() {
  grep -m1 "^$2=" "$1" | cut -d= -f2
}

set_progress() { if ! $BOOTMODE; then echo "set_progress $1" >> $OUTFD; fi }

ui_print() {
  until [ ! "$1" ]; do
     if ! $BOOTMODE; then
        if [ $(echo "$1" | wc -l) -gt 2 ]; then
           local IFS=$'\n' line
           for line in $1; do
             echo "ui_print $line${n}ui_print" >> $OUTFD
           done
        else
           echo "ui_print $1${n}ui_print" >> $OUTFD
        fi
     else 
       echo "$1"
     fi
     shift
  done
}

ch_con() {
  chcon -h u:object_r:${1}_file:s0 "$2"
}

set_perm() {
  chown "$1:$2" "$4"
  chmod "$3" "$4"
}

set_perm2() {
  #Ensure this format
  chown "$1:$2" "$4"
  chmod "$3" "$4"
}

setup_mountpoint() {
  test -L $1 && mv -f $1 ${1}_link
  if [ ! -d $1 ]; then
    rm -f $1
    mkdir $1
  fi
}

is_mounted() { mount | grep -q " $1 "; }

loop_setup() {
  unset loopdev
  local loop
  local minorx=1
  [ -e /dev/block/loop1 ] && minorx=$(stat -Lc '%T' /dev/block/loop1)
  local num=0
  while [ $num -lt 64 ]; do
    loop=/dev/block/loop$num
    [ -e $loop ] || mknod $loop b 7 $((num * minorx))
    if losetup $loop "$1" 2>/dev/null; then
      loopdev=$loop
      break
    fi
    num=$((num + 1))
  done
}

mount_apex() {
  test -d /system/apex || return 1
  local apex dest class apexbin
  setup_mountpoint /apex
  for apex in /system/apex/*; do
    case $apex in
      *.apex)
         dest=/apex/$(apex_pkg "$apex")
         [ -d "$dest" ] || mkdir -p "$dest"
         unzip -qo $apex apex_payload.img -d /apex
         loop_setup /apex/apex_payload.img
         if [ ! -z $loopdev ]; then
           echo2 "Mounting $dest"
           mount -t ext4 -o ro,noatime $loopdev $dest
         fi
         rm -f /apex/apex_payload.img
      ;;
      *)  
         dest=/apex/$(basename $apex .apex)
         [ -d "$dest" ] || mkdir -p "$dest"
         echo2 " Mounting $dest" && mount -o bind $apex $dest
      ;;
    esac
  done
  local APEXRJPATH=$(dirname "$(find /apex -name core-oj.jar -print | head -n 1)")
  export ANDROID_RUNTIME_ROOT=/apex/com.android.runtime
  export ANDROID_ART_ROOT=/apex/com.android.art
  export ANDROID_TZDATA_ROOT=/apex/com.android.tzdata
  local SYSFRAME=/system/framework
  unset BOOTCLASSPATH
  for class in $(find "$APEXRJPATH" -type f -name *.jar); do
    export BOOTCLASSPATH+=$(echo "$class:")
  done
  for class in $(find "$SYSFRAME" -type f -name *.jar); do
    export BOOTCLASSPATH+=$(echo "$class:")
  done
  for apexbin in $(find /apex -type d -name bin); do
    export PATH="$PATH":$apexbin
  done
}

umount_apex() {
  test -d /apex || return 1
  local dest loop
  for dest in $( find /apex -type d -mindepth 1 -maxdepth 1); do
    loop=$( mount |  grep $dest |  cut -d" " -f1)
    ( umount -l $dest
     losetup -d $loop) 
  done
   rm -rf /apex 
  unset ANDROID_RUNTIME_ROOT ANDROID_TZDATA_ROOT BOOTCLASSPATH
}

mount_all() {
  local runtime dest
  if ! is_mounted /data; then
     mount /data
    UMOUNT_DATA=1
  fi
  (mount /cache
  mount -o ro -t auto /persist
  mount -o ro -t auto /product
  mount -o ro -t auto /vendor) 
  setup_mountpoint $ANDROID_ROOT
  if ! is_mounted $ANDROID_ROOT; then
    mount -o ro -t auto $ANDROID_ROOT 
  fi
  case $ANDROID_ROOT in
    /system_root) setup_mountpoint /system;;
    /system)
      if ! is_mounted /system && ! is_mounted /system_root; then
        setup_mountpoint /system_root
        mount -o ro -t auto /system_root
      elif [ -f /system/system/build.prop ]; then
        setup_mountpoint /system_root
        mount --move /system /system_root
      fi
      if [ $? != 0 ]; then
        umount /system
        umount -l /system 
        if [ "$dynamic_partitions" = "true" ]; then
          test -e /dev/block/mapper/system || local slot=$(getprop ro.boot.slot_suffix )
          mount -o ro -t auto /dev/block/mapper/system$slot /system_root
          mount -o ro -t auto /dev/block/mapper/vendor$slot /vendor 
          mount -o ro -t auto /dev/block/mapper/product$slot /product 
        else
          test -e /dev/block/bootdevice/by-name/system || local slot=$(getprop ro.boot.slot_suffix )
          mount -o ro -t auto /dev/block/bootdevice/by-name/system$slot /system_root
        fi
      fi
    ;;
  esac
  if is_mounted /system_root; then
    if [ -f /system_root/build.prop ]; then
      mount -o bind /system_root /system
    else
      mount -o bind /system_root/system /system
    fi
  fi
  if [[ -n "$apex_mount" && "$apex_mount" != "off" ]]; then 
     $BOOTMODE || mount_apex
  else
     if ! $BOOTMODE; then
        runtime=$(find "/system/apex" -name "*com.android.runtime*" -print | head -n 1)
        if [ -z "$runtime" ]; then echo2 "FATAL ERROR: Cant find RUNTIME" && return; fi
        case $runtime in
         *.apex)
            dest=/apex/$(apex_pkg "$runtime")
            if [ ! -d "$dest" ]; then
               mkdir -p "$dest"
               unzip -qo "$runtime" apex_payload.img -d /apex
               loop_setup /apex/apex_payload.img
               if [ ! -z $loopdev ]; then
                 echo2 "Mounting $dest"
                 mount -t ext4 -o ro,noatime $loopdev $dest
               fi
               rm -f /apex/apex_payload.img
            fi
         ;;
         *)  
            dest=/apex/$(basename $runtime .apex)
            [ -d "$dest" ] || mkdir -p "$dest"
            echo2 " Mounting $dest" && mount -o bind $runtime $dest
         ;;
       esac
     fi
  fi
}

umount_all() {
  local part
  (umount_apex
  for part in /system /system_root /cache /persist /vendor /product "${all_umount[@]}"; do
    echo2 " Unmounting $part "
    umount "$part"
    umount -l "$part"
  done
  if [ "$UMOUNT_DATA" ]; then
    umount /data
    umount -l /data
  fi) 
}

dynamic_install(){
   local f inst_dir
   for f in $(find "$1" -mindepth 1 -type f); do
     inst_dir="$(dirname "$f")"
     inst_dir="${inst_dir#$1}"
     inject "$f" "$2${inst_dir}"
   done  
}
	
inject() {
  local file dest
  file="$(basename "$1")"
  dest="$2/$file"
  if [ ! -d "$2" ]; then mkdir -p "$2"; fi
  if install -D "$1" "$dest" >/dev/null 2>&1; then
     set_perm2 0 0 644 "$dest"
     set_perm2 0 0 755 "$2"
  elif cp -prf "$1" "$dest"; then
     set_perm2 0 0 644 "$dest"
     set_perm2 0 0 755 "$2"
  elif mv -f "$1" "$dest"; then
     set_perm2 0 0 644 "$dest"
     set_perm2 0 0 755 "$2"
  else
     echo2 "Cant inject: $file"
  fi
}

auto_mount_partitions() {
    local main block slot
    if ! $BOOTMODE; then
      mount -o bind /dev/urandom /dev/random
      umount_all
      mount_all
    fi
    if [ "$dynamic_partitions" = "true" ]; then
       for block in system vendor product; do
        for slot in "" _a _b; do
          blockdev --setrw /dev/block/mapper/$block$slot 
        done
      done
    fi
    for main in /system /vendor /product; do
       if ! is_mounted "$main"; then
          try_mount "$main" >/dev/null
          if [[ "$main" == "/system" ]]; then mount_all; fi
          if ! is_mounted "$main"; then
             echo2 " CANT MOUNT: $main "
          fi
       fi
    done
    mount -o rw,remount -t auto /system || mount -o rw,remount -t auto /
    mount -o rw,remount -t auto /vendor 
    mount -o rw,remount -t auto /product 
    #Try RW in /system_root
    mount -o bind /system_root /system_root
    mount -o remount,rw /system_root
}
test "$ANDROID_ROOT" || ANDROID_ROOT=/system
getarch

export dynamic_partitions=`getprop ro.boot.dynamic_partitions`
for slot in "$(grep_cmdline androidboot.slot_suffix)" "$(grep_cmdline androidboot.slot)" "$(getprop ro.boot.slot_suffix)"; do
   if [ -n "$slot" ]; then export slot="$slot" && break; fi
done
export n=$'\n'
export yes=chooseport

#Test Mode (Maintenance or just testing for Devs)
if [[ -z "$installzip" && -z "$BOOTMODE" ]]; then
   export testmode=true
   export BOOTMODE=true
   export PATH="$PATH:/sbin:/sbin/su:/su/bin:/su/xbin:/system/bin:/system/xbin:/data/data/com.termux/files/usr/bin:/data/data/com.termux/files/usr/bin/applets"
   echo " >> Test Mode 1.0.0 "
   echo " @BlassGO "
   echo " "
   echo " Loading environment..."
   #Check petecitos
   if [ -e "/etc/lsb-release" ] || [ -n "$OSTYPE" ]; then
     echo "The Test Mode was designed to test Dynamic Installer functions in Termux on Android, dont try to run it on your computer"
     exit 1
   fi
   start_loading -d 0 -s 10 -f 100 -a '|/-\' -l ==========================================
   #Emulate TMP
   export TMP="${PWD}/tmp"
   export addons="$TMP/addons"
   delete_recursive "$TMP" >/dev/null 2>&1
   if [ ! -d "$TMP" ]; then mkdir -p "$TMP"; fi
   add_loading 30
   #Emulate executable space for bin (AAPT/APKTOOL)
   if [ -d "/data" ]; then export l=/data/ogo; else export l="${PWD}/ogo"; fi
   if ! exist file bin; then 
      echo "ERROR: CANT FIND BIN"
   else
      cp -pf "bin" "$TMP/bin.xz" >/dev/null 2>&1
      xz -d "$TMP/bin.xz" >/dev/null 2>&1
      if ! exist file "$TMP/bin"; then echo "ERROR: CANT EMULATE BIN" && exit 1; fi;
      add_loading 10 
      unzip -qo "$TMP/bin" -d "$l" 
      find "$l" -type f -exec chmod 777 {} +;
      export PATH="$PATH:$l"
      add_loading 50 
   fi
fi

#Check TMP2 (For Dual functions operations)
start_tmp
if [ ! -d "$TMP2" ]; then abort "CANT SETUP: TMP2"; fi
end_tmp

#Check Test Mode
if [[ -n "$testmode" && "$testmode" == "true" ]]; then return; fi

# Pre-setup
package_extract_file META-INF/com/google/android/updater-script $TMP/updater-script
package_extract_dir META-INF/addons $addons 
chmod 777 $TMP/updater-script
devices=$(getdefault $TMP/updater-script devices)
apex_mount=$(getdefault $TMP/updater-script apex_mount)
if [[ -n "$devices" && "$devices" != "off" ]]; then
    dcount=0
    setdefault may "
    $(getprop ro.product.device 2>/dev/null) 
    $(getprop ro.build.product 2>/dev/null) 
    $(getprop ro.product.vendor.device 2>/dev/null) 
    $(getprop ro.vendor.product.device 2>/dev/null)
    $(get_file_prop /default.prop ro.product.device 2>/dev/null)
    "
    for huh in $devices; do
       for ugu in $may; do
         if [[ "$huh" == "$ugu" ]]; then dcount=$(($dcount + 1)); fi;
       done
    done
    if [[ "$dcount" == "0" ]]; then abort " -- Incompatible device: Its only for $devices"; fi;
fi

if ! $BOOTMODE; then 
. "$TMP/updater-script"
if [[ "$run_addons" == "on" ]]; then
    unset post
    ls $addons/*.sh  >/dev/null || post=null
    if [ -z "$post" ]; then
       for addon in $addons/*.sh; do . "$addon"; done;
    fi
fi

else

require_new_magisk() {
    ui_print "*******************************"
    ui_print " Please install Magisk v19.0+! "
    ui_print "*******************************"
    exit 1
}

magisk_print() {
  ui_print "----------------------------------------"
  ui_print ' >>> Powered by Magisk '$MAGISK_VER_CODE
  ui_print "----------------------------------------"
  ui_print " "
}

mount /data 2>/dev/null

[ -f /data/adb/magisk/util_functions.sh ] || require_new_magisk
. /data/adb/magisk/util_functions.sh
[ $MAGISK_VER_CODE -lt 19000 ] && require_new_magisk

is_legacy_script() {
  unzip -l "$ZIPFILE" $DNM/install.sh | grep -q install.sh
  return $?
}

setup_flashable() {
  $BOOTMODE && return
  if [ -z $OUTFD ] || readlink /proc/$$/fd/$OUTFD | grep -q /tmp; then
    # We will have to manually find out OUTFD
    for FD in `ls /proc/$$/fd`; do
      if readlink /proc/$$/fd/$FD | grep -q pipe; then
        if ps | grep -v grep | grep -qE " 3 $FD |status_fd=$FD"; then
          OUTFD=$FD
          break
        fi
      fi
    done
  fi
  recovery_actions
}


install_module() {
  
  cd $TMPDIR

  setup_flashable
  mount_partitions
  api_level_arch_detect
  
  # Setup busybox and binaries
  if $BOOTMODE; then
    boot_actions
  else
    recovery_actions
  fi
  
  # Extract prop file
  package_extract_file $DNM/module.prop $TMPDIR/module.prop
  [ ! -f $TMPDIR/module.prop ] && abort "! Unable to extract zip file!"
  
  local MODDIRNAME=modules
  $BOOTMODE && MODDIRNAME=modules_update
  local MODULEROOT=$NVBASE/$MODDIRNAME
  MODID=`grep_prop id $TMPDIR/module.prop`
  MODNAME=`grep_prop name $TMPDIR/module.prop`
  MODAUTH=`grep_prop author $TMPDIR/module.prop`
  MODPATH=$MODULEROOT/$MODID

  # Create mod paths
  rm -rf $MODPATH
  mkdir -p $MODPATH

  if is_legacy_script; then
    package_extract_dir $DNM $TMPDIR
    # Load install script
    magisk_print
    . $TMPDIR/install.sh

    # Callbacks
    on_install

    [ -f $TMPDIR/uninstall.sh ] && cp -af $TMPDIR/uninstall.sh $MODPATH/uninstall.sh
    $SKIPMOUNT && touch $MODPATH/skip_mount
    $PROPFILE && cp -af $TMPDIR/system.prop $MODPATH/system.prop
    cp -af $TMPDIR/module.prop $MODPATH/module.prop
    $POSTFSDATA && cp -af $TMPDIR/post-fs-data.sh $MODPATH/post-fs-data.sh
    $LATESTARTSERVICE && cp -af $TMPDIR/service.sh $MODPATH/service.sh

    set_permissions
  else
    magisk_print

    package_extract_file $DNM/customize.sh $MODPATH/customize.sh

    if ! grep -q '^SKIPUNZIP=1$' $MODPATH/customize.sh 2>/dev/null; then
      package_extract_dir $DNM $MODPATH

      # Default permissions
      set_perm_recursive $MODPATH 0 0 0755 0644
    fi

    # Load customization script
    [ -f $MODPATH/customize.sh ] && . $MODPATH/customize.sh
  fi

  # Handle replace folders
  for TARGET in $REPLACE; do
    ui_print "- Replace target: $TARGET"
    mktouch $MODPATH$TARGET/.replace
  done

  if $BOOTMODE; then
    # Update info for Magisk app
    mktouch $NVBASE/modules/$MODID/update
    cp -af $MODPATH/module.prop $NVBASE/modules/$MODID/module.prop
  fi

  # Copy over custom sepolicy rules
  if [ -f $MODPATH/sepolicy.rule ]; then
    ui_print "- Installing custom sepolicy rules"
    copy_sepolicy_rules
  fi

  # Remove stuff that doesn't belong to modules and clean up any empty directories
  rm -rf \
  $MODPATH/system/placeholder $MODPATH/customize.sh \
  $MODPATH/README.md $MODPATH/.git*
  rmdir -p $MODPATH

  cd /
  if [[ "$run_addons" == "on" ]]; then
      unset post
      ls $addons/*.sh  >/dev/null || post=null
      if [ -z "$post" ]; then
         for addon in $addons/*.sh; do . "$addon"; done;
      fi
  fi
  $BOOTMODE || recovery_cleanup
  rm -rf $TMPDIR

}

if [ $MAGISK_VER_CODE -ge 20400 ]; then
  # New Magisk have complete installation logic within util_functions.sh
  install_module
  exit 0
fi

fi
